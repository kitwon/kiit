webpackJsonp([0xccc7515567d0],{283:function(n,e){n.exports={data:{allMarkdownRemark:{edges:[{node:{excerpt:"\n这次做的是一个类似teambition的团队协作类项目，因为上级反映交互和视觉方面都没有达到要求，以前的代码也没有用模块化和用node做一些自动化的工作，旧代码是基本改不了的，所以就没看以前的代码，直接看着交互跟设计稿就开撸了。\n库选择基本没有什么选择了，angular版本不稳定，pass，react 和 vue之间为什么选后者呢，一方面受公司政治因素影响，另一方面vue文档有中文，template的写法对新手也比较友好，考虑到后期人员配置就选择vue了。\n重构了4个大模块，改版用时大概一个半月，测试时间一周左右，期间没有什么比较大卡进度的问题。下面通过对项目的构建，组织，测试等工作做下记录以及分析。\n\n# 项目构建\n项目创建是使用vue-cli创建的，模版则是使用我自己维护的[vue-mpa](https://github.com/kitwon/vue-mpa)多页模板创建的单页应用🤩(出于对自己的支持，对模版bug的测试，以及切换为单页应用也方便)。除了官方基本的功能外，项目还加入了打包完成后自动删除并拷贝到后台项目文件夹，自动生成jsp模板等一些自动化功能。\n\n",frontmatter:{title:"年底项目复盘",date:"2018-01-23",category:["工作"],path:"/post/2017-review"}}},{node:{excerpt:"\n> 这篇文章大概5500字体左右，可能需要浪费5-10分钟去阅读。\n\n----\n\n> 现在javascript性能已经足够快了，但是很多时候我们的web app还是会出现卡顿的情况。这时候我们首先会想到是去优化我们的js代码，比如将for循环改为while，但其实这些微粒度的优化其实对性能提示是皮毛。看完google的[render performance](https://developers.google.com/web/fundamentals/performance/rendering/)对前端渲染优化有了一个新的认识。\n\n# 几个重要概念\n## 60fps与设备刷新率\n目前大多数设备的刷新率都是60fps。玩游戏的都知道，如果当前刷新率在30-60fps，游戏运行会基本流畅，而少于60fps就会出现卡顿的状况了。web app基本也是如此，如果浏览器渲染帧突然下降，或者帧数低的情况，就出现程序运行卡的情况了。\n\n其中每个帧的预算时间仅比 16 毫秒多一点 (1 秒/ 60 = 16.66 毫秒)。但实际上，浏览器有整理工作要做，因此您的所有工作需要在 10 毫秒内完成。如果无法符合此预算，帧率将下降，并且内容会在屏幕上抖动。 此现象通常称为卡顿，会对用户体验产生负面影响。\n\n",frontmatter:{title:"构建60fps-web-app",date:"2017-09-13",category:["前端"],path:"/post/60fps-web-app"}}},{node:{excerpt:"\n在之前已经写过一篇关于前端单元测试的文章，相关概念就不作阐述了，有兴趣或者有需求的同学可以在往期找一下。然后这里简单介绍一下[jest](http://facebook.github.io/jest/)，这是一个[Facebook OpenSource](https://code.facebook.com/projects/)的一个开源项目。项目已经集成好了一些测试相关的框架的代码，主打的是零配置测试平台（react中应该算是零配置，其他项目还是要手动配置一下的），里面一个比较好地方是支持**快照测试**(为dom结构生成一个快照，每次测试都对比dom结构)。其他一些好用的地方可以自己查看文档，有中文。\n\n# 配置\n首先是安装jest, jset-vue-preprocessor(jest的一个插件，用来解析'.vue'文件的)。\n```shell\n$npm install jest jest-vue-preprocessor --save-dev\n\n$yarn add jest jest-vue-preprocessor --save\n```\n\n",frontmatter:{title:"在vue项目中使用jest进行单元测试",date:"2017-08-18",category:["前端工具"],path:"/post/vue-jest-test"}}},{node:{excerpt:"\n# 类理论\n类／继承描述了一种代码的组织结构形式，这个理论在软件设计中一直作为一个主导的角色。通过学习类理论，能为更好地学习js中的设计模式和对js中原型链的理解打下基础。\n\n类是在软件中对真实世界问题领域的建模方法。如一个经常看见的交通例子。**汽车**可以被看作**交通工具中的一种**，所以在软件开发时可以定义一个`Vehicle`类，`Vehicle`中包含推进器（引擎）、载人能力等方法。定义`Car`时，只要声明它继承或者拓展`Vehicle`这个基础定义就行了，其他交通工具如船、飞机也可以继承`Vehicle`。**这就是类的实例化与继承**。\n\n类的另外一个核心概念是**多态**，这个概念是说夫类的通用行为可以被子类更特殊的行为重写。\n\njavascript中也有类中的`new`和`instanceof`，还有ES6中的`class`关键字，但这些并不是说明js中有**类**的。javascript中只是为了满足类的设计需求而提供一些类似的语法。\n\n## js中实现类复制(混入)\njavascript中的对象机制并不会自动执行复制行为，简单来说javascript中只有对象，并不存在可以实例的类。一个对象并不会复制一个对象，只会把它关联起来(prototype)。\n\n",frontmatter:{title:"深入学习javascript-类",date:"2017-07-20",category:null,path:"/post/js-class"}}},{node:{excerpt:"\n# 关于this\n\n`this`应该是javascript中一个比较复杂的机制了，在日常工作中我们可能有意无意都会使用到这个机制，但是`this`的工作机制真正了解的可能只有皮毛，通过学习这一机制，能够提高对js代码的理解和阅读能力，还有对js程序设计模式有着更深的理解。\n\n# this的指向\nthis是运行时进行绑定的，而不是编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\n\n通过分析调用位置，就能知道this到底引用的是什么。所以，寻找调用位置就能弄清上面的问题，通过一个例子，就能很好地理解这个问题：\n```javascript\nfunction baz() {\n  // 当前调用栈是 baz\n  // 当前调用位置是全局作用域\n\n  console.log('baz');\n  bar(); // bar的调用位置\n}\n\nfunction bar() {\n  // 当前的调用栈是 baz -> bar\n  // 当前的调用位置是baz\n\n  console.log('bar');\n  foo();\n}\n\nfunction foo() {\n  // 当前的调用栈是 baz -> bar -> foo\n  // 当前的调用位置是bar\n\n  console.log('foo');\n}\n\nbaz();\n```\n\n",frontmatter:{title:"深入学习javascript - this",date:"2017-06-27",category:null,path:"/post/js-this"}}},{node:{excerpt:"\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\n\n# 从webpack1中迁移\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\n\n## 配置文件\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\n\n### `module.loaders`变成`module.rules`\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\n\n```javascript\n// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n```\n\n",frontmatter:{title:"webpack2新特性&迁移",date:"2017-06-24",category:["前端工具"],path:"/post/webpack2"}}},{node:{excerpt:"\n# 什么是闭包\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\n\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）\n\n然后看个例子\n```javascript\nfunction foo() {\n\tvar a = 2;\n\n\tfuntion bar() {\n\t\tconsole.log(a);\n\t}\n\n\tbar();\n}\n\nfoo();\n```\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\n\n```javascript\nfucntion foo() {\n\tvar a = 2;\n\n\tfunction bar() {\n\t\tconsole.log(a)\n\t}\n\n\treturn bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n```\n\n",frontmatter:{title:"深入学习javascript-闭包",date:"2017-06-14",category:null,path:"/post/js-closures"}}},{node:{excerpt:"\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\n\n# 主要需求\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\n* URL管理器主要处理爬取的URL的状态。\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\n\n## 入口程序\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\n\n",frontmatter:{title:"用python写一个简单爬虫",date:"2017-06-11",category:null,path:"/post/python-crawler"}}},{node:{excerpt:"\n# 前言\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\n\n# 作用域是什么\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\n\n\n\n## 理解作用域执行过程\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\n\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\n\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\n\n",frontmatter:{title:"深入学习javascript--作用域",date:"2017-05-31",category:null,path:"/post/js-scope"}}},{node:{excerpt:"\n# 题目\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现\n```javascript\nfunction add(x) {\n\tvar fn = function(y) {\n\t\treturn add(x + y);\n\t}\n\n\treturn fn;\n}\n\nconsole.log(add(1)(2)(3))\n```\n\n# 实现方法\n这样写是可以实现调用方式，但是怎么`return x`呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了`object`的`valueOf`和`toString`的方法。然后再跑了一遍。\n```javascript\nfunction add(x) {\n\tvar fn = function(y) {\n\t\treturn add(x + y);\n\t}\n\n\tfn.toString = function() {\n\t\treturn x;\n\t}\n\n\treturn fn;\n}\n\n\n// chrome  function 6\n// firefox function add/fn\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\nconsole.log(add(1)(2)(3))\n\nconsole.log(add(1)(2)(3).toString()) // 6\n```\n\n",frontmatter:{title:"js实现add(1)(2)(3)",date:"2017-05-28",category:["javascript"],path:"/post/add-chain"}}},{node:{excerpt:"\n老前端都知道，js分为同步(sync)和异步(async)两种模式，同步简单来说就是排队，一个接着一个。异步则是函数执行完后执行它的回调函数，而下一个函数不等上一个函数完成就开始执行。使用回调函数能解决大部分的异步问题，但是回调一多就很容易掉进‘回调地狱’，为了解决这个问题，[promise](https://promisesaplus.com/)（CommonJS工作组提出的一种规范）给我们提供了一种更为优雅的解决方式。\n\n下面，我们会尝试实现一个promise，通过实现这个demo，能更好地理解promise的运行方式，使平时在使用的时候更加熟练，也能从实现原理中进行深入探讨，从而达到“知其然且知其所以然”。\n\n\n\n# 初步构建一个Promise\n我们看下平时使用promise处理异步函数时候的使用方式，从调用方法看下大概用什么方式去实现\n```javascript\n// 例1\nfunction getAsyncData() {\n\treturn new Promise(function(resolve, reject) {\n\t\tsetTimeout(function() {\n\t\t\tresolve('promise done!')\n\t\t}, 1000)\n\t})\n}\n\ngetAsyncData().then(function(result) {\n\tconsole.log(result);\n}).then(function() {\n\tconsole.log('done too!');\n})\n```\n\n",frontmatter:{title:"Promise的简单实现",date:"2017-05-17",category:["前端"],path:"/post/js-promise"}}},{node:{excerpt:"\n# 什么是单元-测试?\n- 单元就是相对独立的功能模块，例如一个函数或者一个类。一个完整的模块化的程序，都应该是有许多个单元构成，单元能完成自己的任务，然后与其他单元进行交互 ，从而完成整个程序的功能。\n- 而测试，就是测试啦。\n\n所以单元测试通俗点讲就是对程序每个独立的单元分别测试，保证构成程序的每个模块的正确性，从而保证整个程序的正确运行。\n\n# 为什么要写单元测试？\n单元测试在前端还是不太普及的，因为刚开始前端也是偏向‘UI’那一块的，但随着node的发展，越来越多非‘UI’的前端代码，一个团队也越来越多人参加开发，如果系统一复杂，又或者你的模块提交到npm上面的话，一出错基本就GG了。\n又或者你这样想，测试是逃不掉的，要么在dev上测试，要么在prod上测试，怎么都得测试，而且每次提交都要测试，为什么不写自动测试呢。我也相信大多数程序员也有写完跑跑看的习惯，而单元测试的log都直接打印到console里面，也省去了很多编译，打包的时间，又能满足各位的心理需求（猥琐脸），一举两得啊。\n\n",frontmatter:{title:"前端单元测试&Mocha指北",date:"2017-05-16",category:["前端"],path:"/post/unit-test"}}},{node:{excerpt:'\n> 原文译自[Smashing Magazine](https://www.smashingmagazine.com/) -- [[How To Develop An Interactive Command Line Application Using Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)\n\n相信很多前端都听说过或者使用过[Gulp](http://www.gulpjs.com.cn/), [Angular CLI](https://cli.angular.io/), [Cordova](https://cordova.apache.org/), [Yeoman](http://yeoman.io/)或其他类似的命令行工具。但有想过这些程序是怎么实现的吗？例如在Angular CLI中使用`ng new <project-name>`后会建立一个已经有基本配置的angular项目；又或者像Yeoman，也能运行时候输入或者选择配置项，让用户能够自定义项目配置，快速搭建好开发时候需要用到的开发环境。下面的教程，就是讲如何使用node写一个像这样的命令行工具。\n\n在这篇教程中，我们会开发一个命令行工具，用户能够输入一个CSV文件地址，从而获取到文件里面的用户信息，然后模拟群发邮件（原文是使用[SendGrid Api](https://github.com/sendgrid/sendgrid-nodejs)模拟发送）\n文章目录：\n1."Hello World"\n2.处理命令行参数\n3.运行时输入参数\n4.模拟发送邮件\n5.改变输出内容样式\n6.变成shell命令\n\n',frontmatter:{title:"使用nodejs写一个命令行程序",date:"2017-05-16",category:["前端"],path:"/post/node-command-app"}}},{node:{excerpt:"\n好久之前做得一个todo demo，使用了最近较火的react和webpack，由于公司电脑各种不能装，所以没用上es6（各种限制太惨了），在这顺便做个记录，年纪大记性太差了。\n\n### 小科普\n什么是React? 按官方解释，框架属于MVC中的view层，由于其设计思想独特，性能出众，逻辑简单，所以上年开始越来越多人关注。\n至于Webpack，各位官人从名字应该可以猜出，是个打包工具，但又不止是个打包工具，是一个支持模块化的打包工具，两个字就可以形容它的优点了，就是暴力，究竟有多暴力，下面demo就为各位官人揭晓！\n\n",frontmatter:{title:"React-todo demo",date:"2016-03-02",category:["js framework"],path:"/post/react-todo"}}}]}},pathContext:{nodes:[{node:{frontmatter:{title:"webpack2新特性&迁移",date:"2017-06-24",category:["前端工具"],tags:["webpack"],path:"/post/webpack2"},excerpt:"\nwebpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。\n\n# 从webpack1中迁移\n官方已经给出了详细的[迁移指南](https://webpack.js.org/guides/migrating/)，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。\n\n## 配置文件\n如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。\n\n### `module.loaders`变成`module.rules`\n旧的`module.loader`被`module.rules`取代，后者允许配置`loader`更多选项，具体查看文档[module.rules](https://webpack.js.org/configuration/module/#module-rules)\n\n```javascript\n// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n```\n\n",headings:[{depth:1,value:"从webpack1中迁移"},{depth:2,value:"配置文件"},{depth:3,value:"变成"},{depth:3,value:"改动"},{depth:3,value:null},{depth:3,value:"CLI中配置使用自定义参数"},{depth:2,value:"主要变更"},{depth:3,value:"ES6模块"},{depth:1,value:"总结"},{depth:2,value:"参考"}],html:"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\n<h1>从webpack1中迁移</h1>\n<p>官方已经给出了详细的<a href=\"https://webpack.js.org/guides/migrating/\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\n<h2>配置文件</h2>\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\"https://webpack.js.org/configuration/module/#module-rules\">module.rules</a></p>\n<pre><code class=\"language-javascript\">// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n</code></pre>\n<!-- more -->\n<pre><code class=\"language-javascript\">// ...\nmodule: {\n    rules: {\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n    }\n}\n// ...\n</code></pre>\n<p>除上面两项外还有</p>\n<ul>\n<li>现在指定loader的时候不能再省略<code>-loader</code>后缀。具体原因参阅<a href=\"https://github.com/webpack/webpack/issues/2986\">#2968</a></li>\n<li><code>json-loader</code>不需再手动添加。</li>\n<li>loader默认的resolve配置是相对于<code>context</code>配置项的。</li>\n<li>取消了<code>module.preLoaders</code>以及<code>module.postLoaders</code>。</li>\n</ul>\n<h3><code>UglifyPlugin</code>改动</h3>\n<ul>\n<li><code>UglifyPlugin</code>的<code>sourceMap</code>现在的默认值的<code>false</code>而不是<code>true</code>。</li>\n<li><code>UglifyJsPlugin</code>的<code>compress.warnings</code>配置项现在默认为<code>false</code>而不是<code>true</code>。</li>\n</ul>\n<h3><code>ExtractTextWebpackPlugin</code></h3>\n<p>插件变化主要体现在语法上，又原来的单个参数传变成了对象，现在的配置方式如下</p>\n<pre><code class=\"language-javascript\">// ExtractTextPlugin.extract\nmodule: {\n    rules: [\n        test: /\\.css$/,\n        loader: ExtractTextPlugin.extract({\n            fallbackLoader: 'style-loader',\n            loader: 'css-loader',\n            publicPath: '/dist'\n        })\n    ]\n}\n\n// new ExtractTextPlugin({options})\nplugins: [\n    new ExtractTextPlugin({\n        filename: 'bundle.css',\n        disabled: true,\n        allChunks: true\n    })\n]\n</code></pre>\n<h3>CLI中配置使用自定义参数</h3>\n<p>在webpack1中可以用<code>process.argv</code>获取自定义参数，但是在webpack2中这行为被禁止了，替代地提供了一个接口<code>env</code>去获取自定义参数</p>\n<pre><code class=\"language-javascript\">module.export = function(env) {\n    var customStuff = env.customStuff;\n\n    // ...\n    return config;\n};\n</code></pre>\n<h2>主要变更</h2>\n<h3>ES6模块</h3>\n<p>webpack2现在增加对ES6的模块化的原生支持，意味着现在能够直接识别<code>import</code>和<code>export</code>了，不需要先转成CommonJS模块的格式。\n支持原生<code>import</code>带来的影响就是支持异步加载模块，webpack1使用异步模块的时候如下</p>\n<pre><code class=\"language-javascript\">require.ensure(['a'], function(a) {\n    a.doSomething()\n}, 'chunkName')\n</code></pre>\n<p>webpack2的<code>import</code>会返回一个<code>promise</code>对象</p>\n<pre><code class=\"language-javascript\">import('a').then(function(a) {\n    a.doSomething()\n})\n</code></pre>\n<p>而且现在<strong>chunk加载失败能被Promise捕捉到</strong>，那就意味着我们能够在组件加载失败的时候采取相应的操作。</p>\n<p>另外现在<code>import</code>还支持动态表达式。</p>\n<pre><code class=\"language-javascript\">function route(path, query) {\n    return import('/routes/${path}/route').then(route => new route.Route(query);\n    })\n}\n</code></pre>\n<h1>总结</h1>\n<p>用着<em>vim-mode</em>，写完这篇已经完全头皮发麻了，完全熟悉估计不知道还要多久呢。回正题，·从官方文档来看，改动的地方的确不多，迁移成本应该是比较低的，至于要不要迁移我觉得还是见仁见智吧，如果新版的优点好处大于迁移的成本的话各位应该可以放心去改动你的配置文件了。总的来说webpack2有以下几个优点</p>\n<ul>\n<li>编译速度提高</li>\n<li>编译文件大小相对减少了</li>\n<li>支持promise</li>\n<li>能捕捉到chunk加载失败</li>\n</ul>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://webpack.js.org/guides/migrating/\">Migrating from v1 to v2</a></li>\n<li><a href=\"http://www.tuicool.com/articles/aieAnan\">升级到 webpack2</a></li>\n<li><a href=\"http://imweb.io/topic/58666d57b3ce6d8e3f9f99b0\">webpack2 的 tree-shaking 好用吗？</a></li>\n</ul>",htmlExcerpt:"<p>webpack2已经发布了好一段时间了。但是因为之前工作的关系没有好好研究一下，后面工作应该会用得上，而且趁着这段时间有空，还有在熟悉vim，就顺便拿这来练练手了。</p>\n<h1>从webpack1中迁移</h1>\n<p>官方已经给出了详细的<a href=\"https://webpack.js.org/guides/migrating/\">迁移指南</a>，改动并不是很大，但是优化却蛮多的，如编译速度，代码优化等。如果你的项目正在用webpack，那么这个新版本还是挺值得迁移的。</p>\n<h2>配置文件</h2>\n<p>如果升级webpack之后直接运行命令的话应该会看到一片红的，可以看出配置项有改动，下面整理一下经常使用地方的改动。</p>\n<h3><code>module.loaders</code>变成<code>module.rules</code></h3>\n<p>旧的<code>module.loader</code>被<code>module.rules</code>取代，后者允许配置<code>loader</code>更多选项，具体查看文档<a href=\"https://webpack.js.org/configuration/module/#module-rules\">module.rules</a></p>\n<pre><code class=\"language-javascript\">// ...\nmdoule: {\n    rules: [\n        {\n            test: /\\.css$/,\n            use: [\n                { loader: 'style-loader' },\n                {\n                    loader: 'css-loader',\n                    options: { module: true }\n                }\n            ]\n        },\n        {\n            test: /\\.jsx$/,\n            loader: 'babel-loader',\n            options: {\n                // ...\n            }\n        }\n    ]\n}\n// ...\n</code></pre>\n"}},{node:{frontmatter:{title:"深入学习javascript-闭包",date:"2017-06-14",category:null,tags:null,path:"/post/js-closures"},excerpt:"\n# 什么是闭包\n记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。\n\n> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）\n\n然后看个例子\n```javascript\nfunction foo() {\n\tvar a = 2;\n\n\tfuntion bar() {\n\t\tconsole.log(a);\n\t}\n\n\tbar();\n}\n\nfoo();\n```\n如果按上面第一条的定义，这里一定是生成了闭包，但是**确切的说并不是**，这里最准确的说是`bar`对`a`的引用方式是词法作用域的查找规则，而这些只是**闭包**的一部分。然后再看清晰闭包的例子\n\n```javascript\nfucntion foo() {\n\tvar a = 2;\n\n\tfunction bar() {\n\t\tconsole.log(a)\n\t}\n\n\treturn bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n```\n\n",headings:[{depth:1,value:"什么是闭包"},{depth:1,value:"闭包与变量"},{depth:1,value:"模块"},{depth:2,value:"现代的模块机制"},{depth:1,value:"总结"}],html:"<h1>什么是闭包</h1>\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\n<blockquote>\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）</p>\n</blockquote>\n<p>然后看个例子</p>\n<pre><code class=\"language-javascript\">function foo() {\n    var a = 2;\n\n    funtion bar() {\n        console.log(a);\n    }\n\n    bar();\n}\n\nfoo();\n</code></pre>\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\n<pre><code class=\"language-javascript\">fucntion foo() {\n    var a = 2;\n\n    function bar() {\n        console.log(a)\n    }\n\n    return bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n</code></pre>\n<!-- more -->\n<p>在这例子中，<code>bar</code>也是在<code>foo</code>的作用域内，但是不是直接执行，而是作为返回值返回。\n<code>foo()</code>执行后，返回值<code>bar</code>赋值给<code>baz</code>并执行<code>baz()</code>，在这里，<code>bar()</code>显然可以正常执行，它在自己定义的词法作用域<strong>以外</strong>的地方。</p>\n<p>在<code>foo()</code>执行之后，按js的垃圾回收机制，应该会对其进行回收，而闭包的神奇之处就是可以阻止这事情发生，因此<code>baz()</code>在执行的时候依然可以访问<code>a</code>。在此一看，原来平时写的大多数代码都是闭包啊。</p>\n<pre><code class=\"language-javascript\">function foo() {\n    var a = 2;\n\n    function bar() {\n        console.log(a);\n    }\n\n    baz(bar);\n}\n\nfunction baz(fn) {\n    fn &#x26;&#x26; fn(); // 这里也是闭包\n}\n</code></pre>\n<h1>闭包与变量</h1>\n<p>要说明闭包，for循环也是一个很好的例子</p>\n<pre><code class=\"language-javascript\">for(var i = 1; i &#x3C;= 10; i++) {\n    setTimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n</code></pre>\n<p>正常情况下，我们会预期的认为这段会每秒输出1～10，但实际，这段代码会<strong>每秒输出10次11</strong>。</p>\n<p>首先<strong>11</strong>是那里来的，这个循环应该是在<code>i=11</code>的时候符合终止条件，所以代码输出的是循环结束时<strong>i</strong>的最终值。</p>\n<p>细想一下，答案其实显而易见，<strong>setTimeout</strong>会推到栈底部执行，所以会在循环结束后才开始执行，所以每次都是输出<strong>11</strong>。但是什么问题造成这样的结果呢。</p>\n<p>虽然<strong>setTimeout</strong>都是在每个迭代时候分别定义的，但是根据作用域原理，其实几个函数都是都是<strong>保存在一个封闭的作用域中</strong>，因此它们引用都是同一个<strong>来自全局的i</strong>。</p>\n<p>所以解决方法也很简单，我们需要每次循环都新建一个作用域，然后把迭代的值传入作用域中，所以我们可以用<strong>IIFE</strong>（上一篇作用域有介绍，IIFE是一个匿名函数，每次调用都会创建作用域）来解决</p>\n<pre><code class=\"language-javascript\">for(var i = 1; i &#x3C;= 10; i++) {\n    (function(j) {\n        setTimeout(function timer() {\n            console.log(j)\n        }, j * 1000)\n    })(i)\n}\n\n// 换成ES6中的let也可以\nfor(let i = 1; i &#x3C;= 10; i++) {\n    setTimeout(function timer() {\n        console.log(i)\n    }, i * 1000)\n}\n</code></pre>\n<h1>模块</h1>\n<p>闭包除了平时实现的回调功能外，还可以实现另外一个强大的功能，<strong>模块</strong>。\n旧的模块实现方式，如jQuery就可以使用闭包实现</p>\n<pre><code class=\"language-javascript\">var $ = jQuery = (function Module(id) {\n    var a = 2;\n\n    function doSomething() {\n        console.log(a);\n    }\n\n    function identify1() {\n        console.log(id);\n    }\n\n    function identify2() {\n        console.log(id.toUpperCase());\n    }\n\n    function change() {\n        public.identify = identify2;\n    }\n\n    var public = {\n        doSomething: doSomething,\n        identify: identify1,\n        change: change\n    }\n\n    return public;\n})('hello')\n\n$.doSomething() // 2\n$.identify() // hello\n$.change()\n$.identify() // HELLO\n</code></pre>\n<p>如果不用单例的话不用<strong>IIFE</strong>即可，通过在模块内保留对公共API的引用，可以从<strong>内部</strong>对模块实例进行修改，包括添加，删除，修改属性或者方法。</p>\n<h2>现代的模块机制</h2>\n<p>现在大部分的模块加载器本质上都是将这种模块定义封装进API中，如下代码</p>\n<pre><code class=\"language-javascript\">var Module = (function Manager() {\n    var modules = {};\n\n    function define(name, deps, impl) {\n        for(var i = 0; i &#x3C; deps.length; i++) {\n            // 在modules中寻找名字为deps[i]的模块\n            deps[i] = modules[deps[i]];\n        }\n        // 将依赖的模块作为arguments传入module中\n        modules[name] = impl.apply(impl, deps);\n    }\n\n    function require(name) {\n        return modules[name];\n    }\n\n    return {\n        define: define,\n        require: require\n    }\n})()\n</code></pre>\n<p>这段代码核心在<code>module[name] = impl.apply(impl, deps)</code>中，模块都按名字保存在<code>modules</code>变量中，每次都能根据获取相关模块。下面看看使用方式。</p>\n<pre><code class=\"language-javascript\">Module.define('foo', [], function() {\n    function hello(who) {\n        return 'Hello ' + who;\n    }\n\n    return {\n        hello: hello\n    }\n})\n\nModule.define('bar', ['foo'], function(foo) {\n    function awsome() {\n        return foo.hello('kit').toUpperCase();\n    }\n\n    return {\n        awsome: awsome\n    }\n})\n\nvar foo = Module.require('foo'),\n    bar = Module.require('bar');\n\nfoo.hello('kit'); // Hello kit\nbar.awsome() // HELLO KIT\n</code></pre>\n<h1>总结</h1>\n<p>从上面可以知道，平时写的js大部分代码都使用了闭包，通过了解闭包和作用域的运行方式，能够减少平时使用的出现的错误。也能通过闭包，使用js实现模块化等其他更多的功能。</p>",htmlExcerpt:'<h1>什么是闭包</h1>\n<p>记得刚开始用js的时候就听过闭包这个概念，一开始觉得只是一个语言特性，没有太深入了解，网上查资料的解释一般是：函数有权访问另一个函数作用域中变量的函数，最容易生成闭包的方式一般是函数里面套函数。</p>\n<blockquote>\n<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域外执行。\n--- 你不知道的javascript（上卷）</p>\n</blockquote>\n<p>然后看个例子</p>\n<pre><code class="language-javascript">function foo() {\n    var a = 2;\n\n    funtion bar() {\n        console.log(a);\n    }\n\n    bar();\n}\n\nfoo();\n</code></pre>\n<p>如果按上面第一条的定义，这里一定是生成了闭包，但是<strong>确切的说并不是</strong>，这里最准确的说是<code>bar</code>对<code>a</code>的引用方式是词法作用域的查找规则，而这些只是<strong>闭包</strong>的一部分。然后再看清晰闭包的例子</p>\n<pre><code class="language-javascript">fucntion foo() {\n    var a = 2;\n\n    function bar() {\n        console.log(a)\n    }\n\n    return bar;\n}\n\nvar baz = foo()；\n\nbaz(); // 这就是闭包效果\n</code></pre>\n'}},{node:{frontmatter:{title:"用python写一个简单爬虫",date:"2017-06-11",category:null,tags:null,path:"/post/python-crawler"},excerpt:"\n之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。\n\n# 主要需求\n这个demo中爬虫有3个主要模块，**URL管理器**、**下载器**、**解析器**\n* URL管理器主要处理爬取的URL的状态。\n* 下载器会通过**URL管理器**传送过来有效URL进行下载。\n* 解析器会将**下载器**下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给**URL管理器**进行重复操作。\n\n## 入口程序\n`spider_main`文件为程序入口，处理整个爬虫的运行逻辑\n\n",headings:[{depth:1,value:"主要需求"},{depth:2,value:"入口程序"},{depth:2,value:"url管理器"},{depth:2,value:"下载器"},{depth:2,value:"解析器"},{depth:1,value:"总结"}],html:"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\n<h1>主要需求</h1>\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\n<ul>\n<li>URL管理器主要处理爬取的URL的状态。</li>\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\n</ul>\n<h2>入口程序</h2>\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\n<!-- more -->\n<pre><code class=\"language-python\">import url_manager, html_downloader, html_outputer, html_parser\nimport sys\n\nclass SpiderMain(object):\n    def __init__(self):\n        self.urls = url_manager.UrlManager()\n        self.downloder = html_downloader.HtmlDownloader()\n        self.parser = html_parser.HtmlParser()\n        self.outputer = html_outputer.HtmlOutputer()\n\n    def crawl(self, root_url):\n        count = 1\n        # 初始化原始的爬取地址\n        self.urls.add_new_ursl(root_url)\n\n        while self.urls.has_new_url():\n            try:\n                new_url = self.urls.get_new_url()\n                print 'crawl %d : %s' % (count, new_url)\n                html_cont = self.downloder.download(new_url)\n                new_urls, new_data = self.parser.parse(new_url, html_cont)\n\n                self.urls.add_new_urls(new_urls)\n                self.outputer.collect_data(new_data)\n\n                # 爬取的数据到1000条时跳出循环\n                if count == 1000:\n                    break\n\n                count = count + 1\n            except:\n                # 使用sys抛出其他函数错误\n                info=sys.exc_info()\n                print info[0],\":\",info[1]\n\n                print 'crawl failed'\n\n        # 将爬取的数据组装\n        self.outputer.output_html()\n\nif __name__ == '__main__':\n    root_url = 'http://baike.baidu.com/item/Python'\n    obj_spider = SpiderMain()\n    obj_spider.crawl(root_url)\n</code></pre>\n<h2>url管理器</h2>\n<pre><code class=\"language-python\"># url_manager.py\nclass UrlManager(object):\n    def __init__(self):\n        self.new_urls = set()\n        self.old_urls = set()\n\n    # 添加一条新的url\n    def add_new_url(self, url):\n        if url is None:\n            return\n\n        if url not in self.new_urls and url not in self.old_urls:\n            self.new_urls.add(url)\n\n    # 添加多条url\n    def add_new_urls(self, urls):\n        if urls is None and len(urls) == 0:\n            return\n\n        for url in urls:\n            self.add_new_url(url)\n\n    # 是否有代爬取地址\n    def has_new_url(self):\n        return len(self.new_urls) != 0\n\n    # 返回一条新的url\n    def get_new_url(self):\n        new_url = self.new_urls.pop()\n        self.old_urls.add(new_url)\n        return new_url\n</code></pre>\n<h2>下载器</h2>\n<p>下载器使用自带的<a href=\"https://docs.python.org/2/library/urllib2.html\">urllib2</a>库处理请求</p>\n<pre><code class=\"language-python\"># html_downloader.py\nimport urllib2\n\nclass HtmlDownloader(object):\n    def download(self, url):\n        if url is None:\n            return\n\n        # 这里设置一下超时，不然网络会使程序运行出现停止\n        response = urllib2.urlopen(url, timeout = 5)\n\n        # 请求失败时候跳出程序\n        if response.getcode() != 200:\n            return None\n\n        return response.read()\n</code></pre>\n<h2>解析器</h2>\n<p>解析器分为两部分，一个解析，一个输出，首先看看解析模块。</p>\n<p>解析html我们使用了<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html\">beautifulsoup</a>，解析后可以使用库提供的方法做DOM操作，获取有用的信息</p>\n<pre><code class=\"language-python\"># html_parser.py\nfrom bs4 import BeautifulSoup\nimport re\nimport urlparse\n\nclass HtmlParser(object):\n    def _get_new_urls(self, page_url, soup):\n        new_urls = set()\n\n        # 获取a标签中所有匹配的url地址\n        links = soup.find_all('a', href=re.compile(r'/item/'))\n        for link in links:\n            new_url = link['href']\n            new_full_url = urlparse.urljoin(page_url, new_url)\n            new_urls.add(new_full_url)\n\n        return new_urls\n\n    def _get_new_data(self, page_url, soup):\n        res_data = {}\n\n        # 获取页面相关内容\n        res_data['url'] = page_url\n\n        # &#x3C;dd class=\"lemmaWgt-lemmaTitle-title\"> &#x3C;h1>Python&#x3C;/h1>\n        title_node = soup.find('dd', class_='lemmaWgt-lemmaTitle-title').find('h1')\n        res_data['title'] = title_node.get_text()\n\n        # &#x3C;div class=\"lemma-summary\" label-module=\"lemmaSummary\">\n        summary_node = soup.find('div', class_='lemma-summary')\n        res_data['summary'] = summary_node.get_text()\n\n        return res_data\n\n    def parse(self, page_url, html_cont):\n        if page_url is None or html_cont is None:\n            return\n\n        soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8')\n        new_urls = self._get_new_urls(page_url, soup)\n        new_data = self._get_new_data(page_url, soup)\n\n        return new_urls, new_data\n</code></pre>\n<pre><code class=\"language-python\"># html_outputer.py\nclass HtmlOutputer(object):\n    def __init__(self):\n        self.datas = []\n\n    # 获取到的页面内容对象push到数组中\n    def collect_data(self, data):\n        if data is None:\n            return\n\n        self.datas.append(data)\n\n    # 将数组循环拼接，写入html文件中\n    def output_html(self):\n        fout = open('output.html', 'w')\n\n        fout.write('&#x3C;html>')\n        fout.write('&#x3C;body>')\n        fout.write('&#x3C;table>')\n\n        for data in self.datas:\n            fout.write('&#x3C;tr>')\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['url'])\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['title'].encode('utf-8'))\n            fout.write('&#x3C;td>%s&#x3C;/td>'%data['summary'].encode('utf-8'))\n            fout.write('&#x3C;/tr>')\n\n        fout.write('&#x3C;/html>')\n        fout.write('&#x3C;/body>')\n        fout.write('&#x3C;/table>')\n</code></pre>\n<h1>总结</h1>\n<p>短短几行代码就实现了一个简单的爬虫，足以体现python的简单易用。学习python主要是想了解一下机器学习，后面会看一些书籍和资料，应该会再记录，但是后面估计会先写完深度学习javascript系列先。</p>",htmlExcerpt:"<p>之前一直有学习python，但是一直都是在学一些比较基础的东西，所在在这段空闲的时间打算系统学一下python。在这会使用python写一个爬百科的简单爬虫，首先分析下爬虫的需求。</p>\n<h1>主要需求</h1>\n<p>这个demo中爬虫有3个主要模块，<strong>URL管理器</strong>、<strong>下载器</strong>、<strong>解析器</strong></p>\n<ul>\n<li>URL管理器主要处理爬取的URL的状态。</li>\n<li>下载器会通过<strong>URL管理器</strong>传送过来有效URL进行下载。</li>\n<li>解析器会将<strong>下载器</strong>下载的内容解析成字符串，再进行保存。如果解析出有效URL再传给<strong>URL管理器</strong>进行重复操作。</li>\n</ul>\n<h2>入口程序</h2>\n<p><code>spider_main</code>文件为程序入口，处理整个爬虫的运行逻辑</p>\n"}},{node:{frontmatter:{title:"深入学习javascript--作用域",date:"2017-05-31",category:null,tags:null,path:"/post/js-scope"},excerpt:"\n# 前言\n使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。\n\n# 作用域是什么\nJS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为**作用域**。\n\n\n\n## 理解作用域执行过程\n如在`var a = 2`执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。\n\n首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\n1. 遇到var a，编译器会在**作用域**中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\n2. 接下来，编译器会为**引擎**生成运行时所需的代码，代码用来处理`a = 2`这个赋值操作。引擎运行时会首先询问**作用域**当前作用集合是否有一个`a`的变量。如果是，**引擎**就会使用这个变量；如果不是，引擎会继续查找该变量。如果**引擎**找到`a`变量，就会赋值2。否则，**引擎**会抛出一个异常。\n\n**总结**：变量赋值分别有两个动作，**编译器**会在当前**作用域**中声明一个变量（如果之前没有声明过），然后在运行时引擎会在**作用域**中查找该变量，如果能找到就对变量进行赋值。\n\n",headings:[{depth:1,value:"前言"},{depth:1,value:"作用域是什么"},{depth:2,value:"理解作用域执行过程"},{depth:3,value:"LSH和RSH查询"},{depth:2,value:"提升"},{depth:3,value:"函数优先"},{depth:2,value:"作用域嵌套"},{depth:1,value:"函数作用域"},{depth:1,value:"块作用域"},{depth:2,value:"延长作用域链(块作用域)"},{depth:1,value:"总结"}],html:'<h1>前言</h1>\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\n<h1>作用域是什么</h1>\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\n<h2>理解作用域执行过程</h2>\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。</p>\n<ol>\n<li>遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。</li>\n<li>接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</li>\n</ol>\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\n<!-- more -->\n<h3>LSH和RSH查询</h3>\n<p>定义一个变量<code>var a = 2</code>，或者执行一个简单的函数<code>console.log(2)</code>中，会同时或者单独出现<strong>LSH</strong>或者<strong>RSH</strong>查询。其实在作用域执行过程中，第一步就是LSH查询，第二步就是RSH查询，简单点来说</p>\n<ul>\n<li>LSH查询就是找到变量的容器本身</li>\n<li>RSH查询就是找到容器的原值</li>\n</ul>\n<pre><code class="language-javascript">// var a就是LSH\n// a = 2就是RSH\nvar a = 2;\n\n// 这里的a其实就是做了一个RSH查询\nconsole.log(a)\n</code></pre>\n<p>为什么需要理解这两个概念呢，因为在变量没有声明的情况下，这两种查询的行为是不一样的。</p>\n<pre><code class="language-javascript">function foo(a) {\n    console.log(a + b);\n    b = a;\n}\n\nfoo(2);\n</code></pre>\n<p>在第一次对b做RSH查询时候是无法找到该变量，所以引擎在这时候就会报出一个<code>ReferenceError</code>的错误。第二个b也还没有声明，但是引擎并没有报错，因为这里先做了LSH查询，所以可以知道，LSH查询如果未找到变量，会在全局中定义一个变量b（非严格模式下），再做RSH查询。引擎还有一个<code>TypeError</code>的错误，在试图对一个非函数类型的值执行函数调用，或者引用<code>null</code>, <code>undefined</code>类型值中的属性时候，就会报这个错误。</p>\n<h2>提升</h2>\n<p>很多时候都会认为javascript代码是由上到下一行一行执行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p>\n<pre><code class="language-javascript">a = 2;\n\nvar a;\n\nconsole.log(a);  // 2\n</code></pre>\n<p>还有另外一段</p>\n<pre><code class="language-javascript">console.log(a); // undefined\n\nvar a = 2;\n</code></pre>\n<p>当js执行一个<code>var a = 2</code>的时候，这里并不是我们看到的一个声明，而是<code>var a</code>, <code>a = 2</code>两个声明，<code>var a</code>会在编译阶段执行，<code>a = 2</code>则会在执行阶段执行。所以第二段代码就很容易解释通了，代码执行顺序应该如下</p>\n<pre><code class="language-javascript">var a;\n\nconsole.log(a);\n\na = 2;\n</code></pre>\n<p>而这个函数声明自动移动到顶部，就叫做<strong>提升</strong>。</p>\n<p>提升操作会出现在<strong>每个作用域</strong>中，看以下代码</p>\n<pre><code class="language-javascript">foo();\n\nfunction foo() {\n    console.log(a);\n    var a = 2;\n}\n</code></pre>\n<p>实际执行如下</p>\n<pre><code class="language-javascript">function foo() {\n    var a;\n    console.log(a);\n    a = 2;\n}\n\nfoo();\n</code></pre>\n<p>可以看到，函数声明会被提升到最顶部，但是函数表达式却不会被提升</p>\n<pre><code>foo(); // TypeError\nbar(); // ReferenceError\n\nvar foo = function bar() {\n    ...\n}\n</code></pre>\n<p>在这里要注意，把foo分配到具名函数下，但是具名函数下也无法在所在作用域中运行。上面函数的执行方式应该如下</p>\n<pre><code class="language-javascript">var foo;\n\nfoo(); // TypeError\n\nbar(); // ReferenceError\n\nfoo = function() {\n    var bar = ... self ...\n}\n</code></pre>\n<h3>函数优先</h3>\n<p>从上面可以知道定义变量和声明函数都会触发提升，但是如果在重复声明的代码下，会出现什么情况呢</p>\n<pre><code class="language-javascript">foo(); // 1\n\nvar foo;\n\nfunction foo() {\n    console.log(1);\n}\n\nfoo = function() {\n    console.log(2);\n}\n</code></pre>\n<p>这里会出现<strong>1</strong>而不是<strong>2</strong>！因为函数会首先被提升，再到变量，所以执行顺序应该如下</p>\n<pre><code class="language-javascript">function foo() {\n    console.log(1);\n}\n\nfoo();\n\nfoo = function() {\n    console.log(2);\n}\n</code></pre>\n<p>在一个普通的块( { ... } 的代码)，函数也会提升，如下代码</p>\n<pre><code class="language-javascript">var a = true;\n\nif(a) {\n    function foo() {\n        ...\n    }\n}else {\n    function bar() {\n        ...\n    }\n}\n</code></pre>\n<p>这里的<code>foo</code>和<code>bar</code>都不会按判断来声明函数，所以在判断声明函数并不可靠。</p>\n<h2>作用域嵌套</h2>\n<p>当一个块或者函数嵌套在另一个块或者函数中，就称为作用域嵌套。在当前作用域没有找到某个变量时，<strong>引擎</strong>就会在外层的作用域继续查找，直到找到该变量，或者抵达最外层（全局）作用域为止。</p>\n<pre><code class="language-javascript">function foo(a) {\n    // b在函数中尚未定义，所以在上一个作用域中查找\n    // 在全局中找到变量b，赋值\n    console.log(a + b);\n}\n\nvar b = 2;\n\nfoo(2); // 4\n</code></pre>\n<h1>函数作用域</h1>\n<p>每个函数都有自己的执行环境，或者说函数有自己作用域。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而函数执行之后，栈将其环境弹出，把控制权返回之前的执行环境。函数作用域内的变量访问正是又这个执行机制控制着。而通过这一机制，能实现隐藏作用域中变量或者函数，规避同名标识符之间的冲突。</p>\n<pre><code class="language-javascript">function foo() {\n    function bar(a) {\n        // i会从for块中找到变量容器，然后执行赋值\n        i = 3;\n        console.log(a + i);\n    }\n\n    for(var i = 0; i &#x3C;= 10; i++) {\n        // 执行bar后会给i重新赋值3，满足i&#x3C;=10，函数死循环\n        bar(i * 2);\n    }\n}\n</code></pre>\n<p>这时候只需要在bar内部修改<code>i = 3</code>为<code>var i = 3</code>，将i变为<code>bar</code>中的本地变量即可。除了新建一个函数去隐藏变量，还能通过匿名函数的特性去实现隐藏变量，社区中也称为<strong>IIFE</strong>。</p>\n<pre><code class="language-javascript">var a = 2;\n\n(function() {\n    var a = 3;\n    console.log(a); // 3\n})()\n\nconsole.log(a); // 2\n</code></pre>\n<p>还能当作函数调用传参</p>\n<pre><code class="language-javascript">var a = 2;\n\n(function(global) {\n    var a = 3;\n\n    console.log(a); // 3\n    console.log(global.a); // 2\n})(window)\n</code></pre>\n<p>通过隐藏变量活着函数，能实现<strong>全局命名空间</strong>或者<strong>JS模块化</strong>(后面会讨论到)。</p>\n<h1>块作用域</h1>\n<p>在JS中块作用域并不常见，但是某些代码却经常会被误以为是块作用域，所以很容易造成理解上的错误，例如下面的常用代码</p>\n<pre><code class="language-javascript">for(var i = 0; i &#x3C; 10; i++) {\n    console.log(i);\n}\n\nif(true) {\n    var foo = \'bar\';\n}\n\nconsole.log(i, foo); // 10 bar\n</code></pre>\n<p>上面代码的<code>i</code>和<code>foo</code>其实都在外部作用域中定义的，而不是在代码块中定义的变量，所以平时在这些代码中定义变量应该是距离使用的地方越近越好。</p>\n<h2>延长作用域链(块作用域)</h2>\n<ul>\n<li>\n<p>with语句。with从对象中创建出来的对象只在with声明中有效。</p>\n<pre><code class="language-javascript">function foo() {\nvar qs = "?bar=true";\n\nwith(location) {\n    // href实际是location.href，只能在with内部使用\n    var url = href + qs;\n}\n\nreturn url;\n}\n</code></pre>\n</li>\n<li>\n<p>try/catch中的catch分句会创造一个块作用域，声明的错误对象变量仅在catch内部有效。</p>\n<pre><code class="language-javascript">try {\nundefined(); // 强制执行一个错误操作\n} catch(err) {\nconsole.log(err);\n}\n</code></pre>\n</li>\n</ul>\n<p>console.log(err); // ReferenceError</p>\n<pre><code>## let/const\n在ES6中，引入了let和const，提供了除var以外的另一种声明变量的方式。用let/const声明的变量会绑定在所在的所用域中（通常是{ ... }内部，换句话说，let/const能劫持所在作用域。\n```javascript\n// 修改下上面的循环例子\nfor(let i = 0; i &#x3C; 10; i++) {\n    console.log(i);\n}\n\nconsole.log(i); // ReferenceError\n</code></pre>\n<p>const在使用方法上跟len是一样，只是创建的值是固定的（常量）。后面任何修改值的操作都会报错。<strong>(注：const实际保证的并不是常量不能改变，而是变量的内存地址不能改变，所以对于复杂的类型object，也只能保证对象的指针地址是固定的，但是对象内部的数据结构则不能固定)</strong></p>\n<pre><code class="language-javascript">const foo = {};\n\nfoo.bar = \'bar\';\nconsole.log(foo.bar); // bar\n\nfoo = {}; // TypeError\n</code></pre>\n<h1>总结</h1>\n<p>通过学习js中的作用域运行方式，了解变量在执行环境的声明周期，以及哪部分代码能访问其中的变量。能为后面学习<strong>闭包</strong>还有实现模块化打下基础。以下是关于作用域的几点总结：</p>\n<ul>\n<li>函数局部环境不仅有访问函数作用域的变量的权限，而且还有权访问其包含(父)环境的变量。</li>\n<li>除全局、函数作用域外，还有比较少用的块作用域。</li>\n</ul>',
htmlExcerpt:"<h1>前言</h1>\n<p>使用js已经有一段时间了，一开始觉得js只是一门玩具语言，用来做做前端交互效果。但是随着越来越深入，慢慢发现js的其他优点：灵活的自由的代码编写带来多种多样的设计方式，令人慢慢着迷。但是很多时候都感觉只是停留在如何使用js实现相关的功能，偶尔遇到一些特殊的情况或者需要深度优化的点，就会感到惘然，为了打破这尴尬情况，打算开始读相关的一些书籍来分析js更深层的设计还有使用方式，从而“达到知其然且知其所以然”。</p>\n<h1>作用域是什么</h1>\n<p>JS中每个函数都有自己的执行环境，在执行环境中能够储存变量中的值，并且能在之后对值进行访问或者修改。换句话说，规定变量储存在哪里，程序要如何找到这些变量，这套规则就称为<strong>作用域</strong>。</p>\n<h2>理解作用域执行过程</h2>\n<p>如在<code>var a = 2</code>执行过程中，分别有引擎、编译器、作用域三个参与了这次过程。</p>\n<p>首先，编译器会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。\n1. 遇到var a，编译器会在<strong>作用域</strong>中查找是有已经存在有该名称的变量。如果是，编译器会忽略这一声明，继续编译；否则，会要求作用域在当前作用域集合中声明一个新变量，并命名为a。\n2. 接下来，编译器会为<strong>引擎</strong>生成运行时所需的代码，代码用来处理<code>a = 2</code>这个赋值操作。引擎运行时会首先询问<strong>作用域</strong>当前作用集合是否有一个<code>a</code>的变量。如果是，<strong>引擎</strong>就会使用这个变量；如果不是，引擎会继续查找该变量。如果<strong>引擎</strong>找到<code>a</code>变量，就会赋值2。否则，<strong>引擎</strong>会抛出一个异常。</p>\n<p><strong>总结</strong>：变量赋值分别有两个动作，<strong>编译器</strong>会在当前<strong>作用域</strong>中声明一个变量（如果之前没有声明过），然后在运行时引擎会在<strong>作用域</strong>中查找该变量，如果能找到就对变量进行赋值。</p>\n"}},{node:{frontmatter:{title:"js实现add(1)(2)(3)",date:"2017-05-28",category:["javascript"],tags:null,path:"/post/add-chain"},excerpt:"\n# 题目\n之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现\n```javascript\nfunction add(x) {\n\tvar fn = function(y) {\n\t\treturn add(x + y);\n\t}\n\n\treturn fn;\n}\n\nconsole.log(add(1)(2)(3))\n```\n\n# 实现方法\n这样写是可以实现调用方式，但是怎么`return x`呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了`object`的`valueOf`和`toString`的方法。然后再跑了一遍。\n```javascript\nfunction add(x) {\n\tvar fn = function(y) {\n\t\treturn add(x + y);\n\t}\n\n\tfn.toString = function() {\n\t\treturn x;\n\t}\n\n\treturn fn;\n}\n\n\n// chrome  function 6\n// firefox function add/fn\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\nconsole.log(add(1)(2)(3))\n\nconsole.log(add(1)(2)(3).toString()) // 6\n```\n\n",headings:[{depth:1,value:"题目"},{depth:1,value:"实现方法"}],html:'<h1>题目</h1>\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    return fn;\n}\n\nconsole.log(add(1)(2)(3))\n</code></pre>\n<h1>实现方法</h1>\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    fn.toString = function() {\n        return x;\n    }\n\n    return fn;\n}\n\n\n// chrome  function 6\n// firefox function add/fn\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\nconsole.log(add(1)(2)(3))\n\nconsole.log(add(1)(2)(3).toString()) // 6\n</code></pre>\n<!-- more -->\n<p>由此看出在不同客户端下返回的结果并不一样，并不是完美的结果，但是查阅了其他资料并没有其他十分好的解决办法，估计这道题的考查点是关于js深度的，比如原生对象里面的基本方法和<code>alert</code>, <code>console</code>会自动执行toString等方法。</p>\n<p>另外，<code>valueOf</code>和<code>toString</code>方法其实是差不多的，返回的结果基本都是相同的，但是试了一下定义了两个不同的方法，发现总是会返回valueOf的值先，所以觉得toString应该是应用于valueOf的结果。</p>',htmlExcerpt:'<h1>题目</h1>\n<p>之前在YY面试的时候遇到过的一题: 实现add(1)(2)(3)，返回6，注意可拓展性。\n当时第一反应就是用递归实现</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    return fn;\n}\n\nconsole.log(add(1)(2)(3))\n</code></pre>\n<h1>实现方法</h1>\n<p>这样写是可以实现调用方式，但是怎么<code>return x</code>呢，回来想还是一脸懵逼，于是上网找了点其他人的实现方式，发现他们是重写了<code>object</code>的<code>valueOf</code>和<code>toString</code>的方法。然后再跑了一遍。</p>\n<pre><code class="language-javascript">function add(x) {\n    var fn = function(y) {\n        return add(x + y);\n    }\n\n    fn.toString = function() {\n        return x;\n    }\n\n    return fn;\n}\n\n\n// chrome  function 6\n// firefox function add/fn\n// node    { [Number: 6] toString: [Function], valueOf: [Function] }\nconsole.log(add(1)(2)(3))\n\nconsole.log(add(1)(2)(3).toString()) // 6\n</code></pre>\n'}}],page:2,pages:3,total:14,limit:5,prev:"/blog/1",next:"/blog/3"}}}});
//# sourceMappingURL=path---blog-2-b378c37e75e2506ec379.js.map